package net.goldenstack.loot;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.Range;

import java.util.ArrayList;
import java.util.List;

/**
 * An entry in a loot table that can generate a list of {@link Choice choices} that each have their own loot and weight.
 */
public interface LootEntry {

    /**
     * Generates any number of possible choices to choose from when generating loot.
     * @param context the context object, to use if required
     * @return a list, with undetermined mutability, containing the options that were generated
     */
    @NotNull List<Choice> requestChoices(@NotNull LootContext context);

    /**
     * A choice, generated from an entry, that could potentially be chosen.
     */
    interface Choice extends LootGenerator {

        /**
         * Calculates the weight of this choice, to be used when choosing which choices should be used.
         * This number should not be below 1.<br>
         * When using the result of this method, be aware of the fact that it's valid for implementations of this method
         * to return different values even when the provided context is the identical.
         * @param context the context object, to use if required
         * @return the weight of this choice
         */
        @Range(from = 1L, to = Long.MAX_VALUE) long getWeight(@NotNull LootContext context);

        
        /**
         * A choice that uses the standard method of generating weight - adding the {@link #weight()} to the {@link #quality()}
         * where the quality is multiplied by the provided context's luck ({@link LootContextKeys#LUCK}).
         */
        interface Standard extends Choice {

            /**
             * The weight of this choice. When calculating the final weight, this value is simply added to the result.
             * @return the base weight of this choice
             */
            @Range(from = 1L, to = Long.MAX_VALUE) long weight();

            /**
             * The quality of the choice. When calculating the final weight, this number is multiplied by the context's luck
             * value, which is stored at the key {@link LootContextKeys#LUCK}.
             * @return the quality of the choice
             */
            @Range(from = 0L, to = Long.MAX_VALUE) long quality();

            @Override
            default @Range(from = 1L, to = Long.MAX_VALUE) long getWeight(@NotNull LootContext context) {
                return Math.max(1, (long) Math.floor(weight() + quality() * context.get(LootContextKeys.LUCK, 0d)));
            }

        }

    }

    /**
     * Picks a random choice from the choices generated by the provided entries, weighted with each choice's weight. If
     * no choices were generated, null is returned.
     * @param entries the entries to generate choices to choose from
     * @param context the context, to use if needed
     * @return the picked choice, or null if no choices were generated
     */
    static @Nullable Choice pickChoice(@NotNull List<LootEntry> entries, @NotNull LootContext context) {
        List<LootEntry.Choice> choices = new ArrayList<>();
        for (LootEntry entry : entries) {
            choices.addAll(entry.requestChoices(context));
        }

        if (choices.isEmpty()) {
            return null;
        }

        long totalWeight = 0;
        long[] weightMilestones = new long[choices.size()];
        for (int i = 0; i < choices.size(); i++) {
            // Prevent the weight of this choice from being less than 1
            totalWeight += Math.max(1, choices.get(i).getWeight(context));

            weightMilestones[i] = totalWeight;
        }

        long value = context.require(LootContext.RANDOM).nextLong(0, totalWeight);

        LootEntry.Choice choice = choices.getLast();

        for (int i = 0; i < weightMilestones.length; i++) {
            if (value < weightMilestones[i]) {
                choice = choices.get(i);
                break;
            }
        }

        return choice;
    }



}
